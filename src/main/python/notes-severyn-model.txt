y_pred_test = predict_prob_batch(test_set_iterator)


def predict_prob_batch(batch_iterator):
preds = numpy.hstack([pred_prob_fn(batch_x_q, batch_x_a, batch_x_q_overlap, batch_x_a_overlap) for batch_x_q, batch_x_a, batch_x_q_overlap, batch_x_a_overlap, _ in batch_iterator])
return preds[:batch_iterator.n_samples]


pred_prob_fn = theano.function(inputs=inputs_pred,
                    outputs=predictions_prob,
                    givens=givens_pred)

givens_pred = {x_q: batch_x_q,
             x_a: batch_x_a,
             x_q_overlap: batch_x_q_overlap,
             x_a_overlap: batch_x_a_overlap,
             # x: batch_x
             }

inputs_pred = [batch_x_q,
     batch_x_a,
     batch_x_q_overlap,
     batch_x_a_overlap,
     # batch_x,
     ]

predictions_prob = test_nnet.layers[-1].p_y_given_x[:,-1]


# retrieve test_nnet from saved pickle
print "Saving to", nnet_fname
  cPickle.dump([train_nnet, test_nnet], open(nnet_fname, 'wb'), protocol=cPickle.HIGHEST_PROTOCOL)

# retrieve best params from saved pickle
  fname = os.path.join(nnet_outdir, 'best_dev_params.epoch={:02d};batch={:05d};dev_acc={:.2f}.dat'.format(epoch, i, best_dev_acc))
  numpy.savetxt(os.path.join(nnet_outdir, 'test.epoch={:02d};batch={:05d};dev_acc={:.2f}.predictions.npy'.format(epoch, i, best_dev_acc)), y_pred)
  cPickle.dump(best_params, open(fname, 'wb'), protocol=cPickle.HIGHEST_PROTOCOL)

    print('Training took: {:.4f} seconds'.format(time.time() - timer_train))
  for i, param in enumerate(best_params):
    params[i].set_value(param, borrow=True)


    test_nnet.params = best_params ??

    nn_layers - load_nnet